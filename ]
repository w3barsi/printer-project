import { v } from "convex/values";
import { Id } from "./_generated/dataModel";
import { internalMutation } from "./_generated/server";
import { authedMutation, authedQuery } from "./auth";
import { cashflowType } from "./schema";

export const createCashflow = authedMutation({
  args: {
    amount: v.number(),
    description: v.string(),
    type: cashflowType,
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("cashflow", {
      amount: args.amount,
      description: args.description,
      createdBy: ctx.user.subject as Id<"users">,
      createdAt: new Date().getTime(),
      type: args.type ?? "Expense",
    });
  },
});

export const deleteCashflowExpense = authedMutation({
  args: {
    expenseId: v.id("cashflow"),
  },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.expenseId);
  },
});

export const getCashflow = authedQuery({
  args: {
    dayStart: v.number(),
  },
  handler: async (ctx, args) => {
    const { dayStart } = args;
    const dayEnd = dayStart + 24 * 60 * 60 * 1000 - 1;

    const rawPayments = await ctx.db
      .query("payment")
      .withIndex("by_creation_time", (q) => q.gte("_creationTime", dayStart))
      .filter((q) => q.lte(q.field("_creationTime"), dayEnd))
      .collect();

    const payments = await Promise.all(
      rawPayments.map(async (p) => {
        const user = (await ctx.db.get(p.createdBy)) ?? { name: "Unknown" };
        const jo = (await ctx.db.get(p.joId)) ?? { name: "Unknown", joNumber: "Unknown" };
        return {
          type: "Payment" as const,
          ...p,
          createdAt: p._creationTime,
          createdByName: user.name,
          joName: jo.name,
          joNumber: jo.joNumber,
        };
      }),
    );

    const rawCashflow = await ctx.db
      .query("cashflow")
      .withIndex("by_created_at", (q) => q.gte("createdAt", dayStart))
      .filter((q) => q.lte(q.field("_creationTime"), dayEnd))
      .collect();

    const cashflow = await Promise.all(
      rawCashflow.map(async (e) => {
        const user = (await ctx.db.get(e.createdBy)) ?? { name: "Unknown" };
        return {
          ...e,
          type: "Cashflow" as const,
          cashflowType: e.type,
          createdByName: user.name,
        };
      }),
    );

    const data = [...payments, ...cashflow].sort((b, a) => b.createdAt - a.createdAt);

    const startingCash = data.filter(
      (d) => d.type === "Cashflow" && d.cashflowType === "Starting Cash",
    );
  },
});

export const listDayData = authedQuery({
  args: {
    dayStart: v.number(),
    dayEnd: v.number(),
  },
  handler: async (ctx, args) => {
    const payments = await ctx.db
      .query("payment")
      .withIndex("by_creation_time", (q) => q.gte("_creationTime", args.dayStart))
      .filter((q) => q.lte(q.field("_creationTime"), args.dayEnd))
      .collect();

    const shapedPayments = payments.map(async (p) => {
      const user = (await ctx.db.get(p.createdBy)) ?? { name: "Unknown" };
      const jo = (await ctx.db.get(p.joId)) ?? { name: "Unknown", joNumber: "Unknown" };
      return {
        ...p,
        createdByName: user.name,
        joName: jo.name,
        joNumber: jo.joNumber,
      };
    });

    const finalPayments = await Promise.all(shapedPayments);

    const cashflow = await ctx.db
      .query("cashflow")
      .withIndex("by_created_at", (q) => q.gte("createdAt", args.dayStart))
      .filter((q) => q.lte(q.field("_creationTime"), args.dayEnd))
      .collect();

    const cashflowWithType = cashflow.map(async (e) => {
      const user = (await ctx.db.get(e.createdBy)) ?? { name: "Unknown" };
      return {
        ...e,
        createdByName: user.name,
      };
    });

    // ShiftKExpenseType taken from here
    const finalExpenses = await Promise.all(cashflowWithType);

    const totalPayments = payments.reduce((s, p) => s + p.amount, 0);
    const totalCashflowExpenses = cashflow
      .filter((e) => e.type === "Cash Advance" || e.type === "Expense")
      .reduce((s, e) => s + e.amount, 0);
    const totalCashflowIncome = cashflow
      .filter((e) => e.type === "Starting Cash" || e.type === "Income")
      .reduce((s, e) => s + e.amount, 0);

    const totalIncome = totalPayments + totalCashflowIncome;

    return {
      expensesData: finalExpenses,
      totalCashflowExpenses,
      paymentsData: finalPayments,
      paymentsTotal: totalPayments,
      net: totalIncome + totalCashflowExpenses,
    };
  },
});

export const expenseToCashflow = internalMutation({
  handler: async (ctx) => {
    const expenses = await ctx.db.query("expenses").collect();

    for (const expense of expenses) {
      await ctx.db.insert("cashflow", {
        createdBy: expense.createdBy,
        createdAt: expense._creationTime,
        amount: expense.amount,
        type: "Expense",
        description: expense.description,
      });
    }

    // Delete all expenses after migration
    for (const expense of expenses) {
      await ctx.db.delete(expense._id);
    }
  },
});
